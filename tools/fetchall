#!/bin/bash

# GitHub repository details
REPO="austere-labs/collect"

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default options
FORCE_OVERWRITE=false

# Function to print colored output
print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
}

print_info() {
    echo -e "${YELLOW}→${NC} $1"
}

print_header() {
    echo -e "${BLUE}═══════════════════════════════════════════${NC}"
    echo -e "${BLUE}  GitHub Fetch All Tool${NC}"
    echo -e "${BLUE}═══════════════════════════════════════════${NC}"
}

# Function to show usage
show_usage() {
    # Additional colors for help output
    local CYAN='\033[0;36m'
    local MAGENTA='\033[0;35m'
    local BOLD='\033[1m'
    local UNDERLINE='\033[4m'
    local DIM='\033[2m'
    local RESET='\033[0m'
    
    # Header
    echo -e "${CYAN}╔═══════════════════════════════════════════════════════════════╗${RESET}"
    echo -e "${CYAN}║${RESET}  ${BOLD}${MAGENTA}📦 FETCHALL${RESET} - GitHub Resource Downloader                     ${CYAN}║${RESET}"
    echo -e "${CYAN}╚═══════════════════════════════════════════════════════════════╝${RESET}"
    echo ""
    
    # Usage
    echo -e "${BOLD}${BLUE}USAGE:${RESET}"
    echo -e "  ${GREEN}$${RESET} ${CYAN}fetchall${RESET} [${YELLOW}options${RESET}]"
    echo ""
    
    # Options
    echo -e "${BOLD}${BLUE}OPTIONS:${RESET}"
    echo -e "  ${YELLOW}--force${RESET}    ${DIM}→${RESET} Overwrite existing files"
    echo -e "  ${YELLOW}--help${RESET}     ${DIM}→${RESET} Show this help message"
    echo -e "  ${YELLOW}--llm${RESET}      ${DIM}→${RESET} Show detailed LLM-formatted usage guide"
    echo ""
    
    # Repository
    echo -e "${BOLD}${BLUE}SOURCE:${RESET}"
    echo -e "  ${UNDERLINE}https://github.com/$REPO${RESET}"
    echo ""
    
    # Resources
    echo -e "${BOLD}${BLUE}RESOURCES DOWNLOADED:${RESET}"
    echo -e "  ${GREEN}✓${RESET} ${CYAN}movetools${RESET}              ${DIM}(single script, if available)${RESET}"
    echo -e "  ${GREEN}✓${RESET} ${CYAN}tools/*${RESET}                ${DIM}(all scripts from /tools/)${RESET}"
    echo -e "  ${GREEN}✓${RESET} ${CYAN}.claude/commands/*.md${RESET}  ${DIM}(command templates, recursive)${RESET}"
    echo -e "  ${GREEN}✓${RESET} ${CYAN}.gemini/commands/*.toml${RESET} ${DIM}(Gemini TOML configs, recursive)${RESET}"
    echo -e "  ${GREEN}✓${RESET} ${CYAN}guides/*.md${RESET}            ${DIM}(documentation guides)${RESET}"
    echo ""
    
    # Special Features
    echo -e "${BOLD}${BLUE}SPECIAL FEATURES:${RESET}"
    echo -e "  ${YELLOW}•${RESET} Auto-creates missing directories"
    echo -e "  ${YELLOW}•${RESET} Preserves directory structure for commands"
    echo -e "  ${YELLOW}•${RESET} Sets executable permissions on scripts"
    echo -e "  ${YELLOW}•${RESET} Smart parent directory detection"
    echo ""
    
    # Examples
    echo -e "${BOLD}${BLUE}EXAMPLES:${RESET}"
    echo -e "  ${DIM}# Download all (skip existing)${RESET}"
    echo -e "  ${GREEN}$${RESET} ${CYAN}fetchall${RESET}"
    echo ""
    echo -e "  ${DIM}# Force overwrite existing files${RESET}"
    echo -e "  ${GREEN}$${RESET} ${CYAN}fetchall${RESET} ${YELLOW}--force${RESET}"
    echo ""
    
    # Footer
    echo -e "${DIM}For detailed documentation, use: ${CYAN}fetchall --llm${RESET}"
    
    exit 0
}

# Function to show LLM-formatted usage
show_llm_usage() {
    # Additional colors for LLM output
    local CYAN='\033[0;36m'
    local MAGENTA='\033[0;35m'
    local BOLD='\033[1m'
    local UNDERLINE='\033[4m'
    local DIM='\033[2m'
    local RESET='\033[0m'
    
    # Box drawing characters
    local BOX_TOP="╔═══════════════════════════════════════════════════════════════════════╗"
    local BOX_MID="╠═══════════════════════════════════════════════════════════════════════╣"
    local BOX_BOT="╚═══════════════════════════════════════════════════════════════════════╝"
    local BOX_SIDE="║"
    
    # Header
    echo -e "${CYAN}${BOX_TOP}${RESET}"
    echo -e "${CYAN}${BOX_SIDE}${RESET}  ${BOLD}${MAGENTA}📦 FETCHALL USAGE GUIDE${RESET}                                              ${CYAN}${BOX_SIDE}${RESET}"
    echo -e "${CYAN}${BOX_SIDE}${RESET}  ${DIM}Downloads resources from austere-labs/collect repository${RESET}              ${CYAN}${BOX_SIDE}${RESET}"
    echo -e "${CYAN}${BOX_MID}${RESET}"
    echo ""
    
    # Description
    echo -e "${BOLD}${BLUE}📋 DESCRIPTION${RESET}"
    echo -e "  Downloads multiple resources from the ${UNDERLINE}austere-labs/collect${RESET} GitHub repository."
    echo -e "  ${DIM}If run from a 'tools' subdirectory, it will place files in the parent directory.${RESET}"
    echo ""
    
    # Usage
    echo -e "${BOLD}${BLUE}🚀 USAGE${RESET}"
    echo -e "  ${GREEN}$${RESET} ${CYAN}./fetchall${RESET} [${YELLOW}options${RESET}]"
    echo ""
    
    # Options
    echo -e "${BOLD}${BLUE}⚙️  OPTIONS${RESET}"
    echo -e "  ${YELLOW}--force${RESET}    ${DIM}→${RESET} Overwrite existing files in destination directories"
    echo -e "  ${YELLOW}--help${RESET}     ${DIM}→${RESET} Show basic usage information"
    echo -e "  ${YELLOW}--llm${RESET}      ${DIM}→${RESET} Show this enhanced usage guide"
    echo ""
    
    # Repository Details
    echo -e "${BOLD}${BLUE}📂 REPOSITORY DETAILS${RESET}"
    echo -e "  ${BOLD}Source:${RESET} ${UNDERLINE}https://github.com/$REPO${RESET}"
    echo ""
    echo -e "  ${BOLD}Resources Downloaded:${RESET}"
    echo -e "  ${GREEN}✓${RESET} ${CYAN}movetools${RESET}              ${DIM}→ Single script file (if available)${RESET}"
    echo -e "  ${GREEN}✓${RESET} ${CYAN}tools/*${RESET}                ${DIM}→ All scripts from /tools/ directory${RESET}"
    echo -e "  ${GREEN}✓${RESET} ${CYAN}.claude/commands/*.md${RESET}  ${DIM}→ Command template files (recursive)${RESET}"
    echo -e "  ${GREEN}✓${RESET} ${CYAN}.gemini/commands/*.toml${RESET} ${DIM}→ Gemini TOML configs (recursive)${RESET}"
    echo -e "  ${GREEN}✓${RESET} ${CYAN}guides/*.md${RESET}            ${DIM}→ Guide markdown files${RESET}"
    echo ""
    
    # Directory Structure
    echo -e "${BOLD}${BLUE}🗂️  LOCAL DIRECTORY STRUCTURE${RESET}"
    echo -e "  ${MAGENTA}┌─ Project Root${RESET}"
    echo -e "  ${MAGENTA}├─${RESET} ${CYAN}movetools${RESET}           ${DIM}# Single script file${RESET}"
    echo -e "  ${MAGENTA}├─${RESET} ${CYAN}tools/${RESET}              ${DIM}# Scripts directory${RESET}"
    echo -e "  ${MAGENTA}├─${RESET} ${CYAN}.claude/${RESET}"
    echo -e "  ${MAGENTA}│  └─${RESET} ${CYAN}commands/${RESET}       ${DIM}# Command templates${RESET}"
    echo -e "  ${MAGENTA}├─${RESET} ${CYAN}.gemini/${RESET}"
    echo -e "  ${MAGENTA}│  └─${RESET} ${CYAN}commands/${RESET}       ${DIM}# Gemini templates${RESET}"
    echo -e "  ${MAGENTA}└─${RESET} ${CYAN}guides/${RESET}             ${DIM}# Guide files${RESET}"
    echo ""
    echo -e "  ${YELLOW}⚠️  Note:${RESET} ${DIM}When run from tools/ directory, files are placed in parent directory${RESET}"
    echo ""
    
    # Examples
    echo -e "${BOLD}${BLUE}💡 EXAMPLES${RESET}"
    echo -e "  ${DIM}# Download all resources (skip existing)${RESET}"
    echo -e "  ${GREEN}$${RESET} ${CYAN}./fetchall${RESET}"
    echo ""
    echo -e "  ${DIM}# Download and overwrite existing files${RESET}"
    echo -e "  ${GREEN}$${RESET} ${CYAN}./fetchall${RESET} ${YELLOW}--force${RESET}"
    echo ""
    echo -e "  ${DIM}# Show help information${RESET}"
    echo -e "  ${GREEN}$${RESET} ${CYAN}./fetchall${RESET} ${YELLOW}--help${RESET}"
    echo ""
    
    # Features
    echo -e "${BOLD}${BLUE}✨ FEATURES${RESET}"
    echo -e "  ${GREEN}•${RESET} Downloads multiple resource types in one execution"
    echo -e "  ${GREEN}•${RESET} Creates necessary directories automatically"
    echo -e "  ${GREEN}•${RESET} Preserves directory structure for commands"
    echo -e "  ${GREEN}•${RESET} Sets executable permissions for scripts"
    echo -e "  ${GREEN}•${RESET} Shows real-time progress indicators"
    echo -e "  ${GREEN}•${RESET} Provides category-based summary"
    echo -e "  ${GREEN}•${RESET} Skips existing files by default"
    echo -e "  ${GREEN}•${RESET} Uses GitHub CLI for secure API access"
    echo ""
    
    # Requirements
    echo -e "${BOLD}${BLUE}📦 REQUIREMENTS${RESET}"
    echo -e "  ${RED}◆${RESET} ${BOLD}GitHub CLI${RESET} (${CYAN}gh${RESET})    ${DIM}→ Must be installed and authenticated${RESET}"
    echo -e "  ${RED}◆${RESET} ${BOLD}jq${RESET}                  ${DIM}→ Command-line JSON processor${RESET}"
    echo -e "  ${RED}◆${RESET} ${BOLD}base64${RESET}              ${DIM}→ For content decoding${RESET}"
    echo ""
    
    # Error Handling
    echo -e "${BOLD}${BLUE}🛡️  ERROR HANDLING${RESET}"
    echo -e "  The script handles common errors gracefully:"
    echo -e "  ${YELLOW}▸${RESET} Missing GitHub CLI installation"
    echo -e "  ${YELLOW}▸${RESET} Network connectivity issues"
    echo -e "  ${YELLOW}▸${RESET} Repository access problems"
    echo -e "  ${YELLOW}▸${RESET} File system permission errors"
    echo -e "  ${YELLOW}▸${RESET} Continues with other categories if one fails"
    echo ""
    
    # Footer
    echo -e "${CYAN}${BOX_BOT}${RESET}"
    echo ""
    echo -e "${DIM}For more information, visit: ${UNDERLINE}https://github.com/$REPO${RESET}"
    
    exit 0
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --force)
            FORCE_OVERWRITE=true
            shift
            ;;
        --help)
            show_usage
            ;;
        --llm)
            show_llm_usage
            ;;
        *)
            echo "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

print_header
echo ""

# Check if gh CLI is installed
if ! command -v gh &> /dev/null; then
    print_error "GitHub CLI (gh) is not installed"
    echo "Please install it from: https://cli.github.com/"
    exit 1
fi

# Check if jq is installed
if ! command -v jq &> /dev/null; then
    print_error "jq is not installed"
    echo "Please install jq from: https://stedolan.github.io/jq/download/"
    exit 1
fi

# Create temp file for tracking stats
STATS_FILE=$(mktemp)
echo "0 0 0 0 0 0 0 0 0 0 0 0" > "$STATS_FILE"

# Determine the base directory
# If we're in a 'tools' subdirectory, use the parent directory
# Otherwise use the current directory
BASE_DIR="."
if [ "$(basename "$PWD")" = "tools" ] && [ -d "../.git" -o -f "../pyproject.toml" -o -f "../main.py" ]; then
    BASE_DIR=".."
    print_info "Detected execution from tools/ directory, using parent directory"
fi

# Create directories if they don't exist
print_info "Creating necessary directories..."
DIRS_TO_CREATE=("$BASE_DIR/tools" "$BASE_DIR/.claude/commands" "$BASE_DIR/.gemini/commands" "$BASE_DIR/guides")

for dir in "${DIRS_TO_CREATE[@]}"; do
    if [ ! -d "$dir" ]; then
        mkdir -p "$dir"
        if [ $? -ne 0 ]; then
            print_error "Failed to create directory: $dir"
            rm -f "$STATS_FILE"
            exit 1
        fi
        print_success "Created $dir"
    fi
done

echo ""

# Function to update stats
update_stats() {
    local category="$1"
    local action="$2"  # downloaded, skipped, or failed
    
    # Read current stats
    read d_mt s_mt f_mt d_t s_t f_t d_c s_c f_c d_g s_g f_g < "$STATS_FILE"
    
    # Update the appropriate counter
    case "$category" in
        movetools)
            case "$action" in
                downloaded) ((d_mt++)) ;;
                skipped) ((s_mt++)) ;;
                failed) ((f_mt++)) ;;
            esac
            ;;
        tools)
            case "$action" in
                downloaded) ((d_t++)) ;;
                skipped) ((s_t++)) ;;
                failed) ((f_t++)) ;;
            esac
            ;;
        commands)
            case "$action" in
                downloaded) ((d_c++)) ;;
                skipped) ((s_c++)) ;;
                failed) ((f_c++)) ;;
            esac
            ;;
        guides)
            case "$action" in
                downloaded) ((d_g++)) ;;
                skipped) ((s_g++)) ;;
                failed) ((f_g++)) ;;
            esac
            ;;
    esac
    
    # Write updated stats
    echo "$d_mt $s_mt $f_mt $d_t $s_t $f_t $d_c $s_c $f_c $d_g $s_g $f_g" > "$STATS_FILE"
}

# Function to download a file
download_file() {
    local remote_path="$1"
    local local_path="$2"
    local is_executable="$3"
    local category="$4"
    
    # Check if file exists and handle accordingly
    if [ -f "$local_path" ] && [ "$FORCE_OVERWRITE" = false ]; then
        echo -n "  $local_path (exists, skipping)... "
        echo -e "${YELLOW}→${NC}"
        update_stats "$category" "skipped"
        return 0
    fi
    
    if [ -f "$local_path" ]; then
        echo -n "  $local_path (overwriting)... "
    else
        echo -n "  $local_path... "
    fi
    
    # Download the file using gh api
    CONTENT=$(gh api repos/$REPO/contents/$remote_path --jq '.content' 2>/dev/null)
    
    if [ $? -eq 0 ] && [ -n "$CONTENT" ]; then
        # Decode base64 content and save to file
        # First try GNU base64 (common on Linux and macOS with coreutils)
        if echo "$CONTENT" | base64 -d > "$local_path" 2>/dev/null; then
            :  # Success, do nothing
        # If that fails, try macOS native base64
        elif echo "$CONTENT" | base64 -D > "$local_path" 2>/dev/null; then
            :  # Success, do nothing
        else
            # Both failed
            false
        fi
        
        if [ $? -eq 0 ]; then
            # Set executable permissions if needed
            if [ "$is_executable" = true ]; then
                chmod +x "$local_path"
            fi
            echo -e "${GREEN}✓${NC}"
            update_stats "$category" "downloaded"
            return 0
        else
            echo -e "${RED}✗${NC} (decode error)"
            update_stats "$category" "failed"
            return 1
        fi
    else
        echo -e "${RED}✗${NC} (download error)"
        update_stats "$category" "failed"
        return 1
    fi
}

# Function to process a directory recursively for specific file types
process_directory() {
    local path="$1"
    local local_path="$2"
    local category="$3"
    local extension="$4"  # File extension to filter (e.g., "md" or "toml")
    
    # Get contents of current directory
    local contents=$(gh api repos/$REPO/contents/$path 2>/dev/null)
    if [ $? -ne 0 ]; then
        print_error "Failed to fetch contents from $path"
        return 1
    fi
    
    # Process each item
    echo "$contents" | jq -c '.[]' | while IFS= read -r item; do
        name=$(echo "$item" | jq -r '.name')
        type=$(echo "$item" | jq -r '.type')
        
        if [ "$type" = "dir" ]; then
            # Create local directory if it doesn't exist
            new_local_path="$local_path/$name"
            if [ ! -d "$new_local_path" ]; then
                mkdir -p "$new_local_path"
            fi
            # Recursively process subdirectory
            process_directory "$path/$name" "$new_local_path" "$category" "$extension"
        elif [ "$type" = "file" ] && [[ "$name" == *.$extension ]]; then
            # Download the file with matching extension
            download_file "$path/$name" "$local_path/$name" false "$category"
        fi
    done
}

# 1. Download movetools (if it exists in the repository)
print_info "Fetching movetools..."
# First check if movetools exists in the repository
MOVETOOLS_CHECK=$(gh api repos/$REPO/contents/movetools 2>/dev/null)
if [ $? -eq 0 ]; then
    download_file "movetools" "$BASE_DIR/movetools" true "movetools"
else
    print_info "movetools not found in repository, skipping..."
fi

echo ""

# 2. Download tools/*
print_info "Fetching tools..."
TOOLS_CONTENTS=$(gh api repos/$REPO/contents/tools 2>/dev/null)
if [ $? -eq 0 ]; then
    echo "$TOOLS_CONTENTS" | jq -c '.[]' | while IFS= read -r item; do
        name=$(echo "$item" | jq -r '.name')
        type=$(echo "$item" | jq -r '.type')
        
        if [ "$type" = "file" ]; then
            download_file "tools/$name" "$BASE_DIR/tools/$name" true "tools"
        fi
    done
else
    print_error "Failed to fetch tools directory"
fi

echo ""

# 3. Download .claude/commands/*.md
print_info "Fetching .claude/commands/*.md files..."
process_directory ".claude/commands" "$BASE_DIR/.claude/commands" "commands" "md"

# 4. Download .gemini/commands/*.toml (if it exists in the repo)
print_info "Checking for .gemini/commands in repository..."
GEMINI_CHECK=$(gh api repos/$REPO/contents/.gemini/commands 2>/dev/null)
if [ $? -eq 0 ]; then
    print_info "Found .gemini/commands in repository, downloading .toml files..."
    process_directory ".gemini/commands" "$BASE_DIR/.gemini/commands" "commands" "toml"
else
    print_info ".gemini/commands not found in repository, skipping..."
fi

echo ""

# 5. Download guides/*.md
print_info "Fetching guides..."
GUIDES_CONTENTS=$(gh api repos/$REPO/contents/guides 2>/dev/null)
if [ $? -eq 0 ]; then
    echo "$GUIDES_CONTENTS" | jq -c '.[]' | while IFS= read -r item; do
        name=$(echo "$item" | jq -r '.name')
        type=$(echo "$item" | jq -r '.type')
        
        if [ "$type" = "file" ] && [[ "$name" == *.md ]]; then
            download_file "guides/$name" "$BASE_DIR/guides/$name" false "guides"
        fi
    done
else
    print_error "Failed to fetch guides directory"
fi

# Print summary
echo ""
print_header
echo "Summary:"
echo ""

# Read final stats
read d_mt s_mt f_mt d_t s_t f_t d_c s_c f_c d_g s_g f_g < "$STATS_FILE"

# Calculate totals
TOTAL_DOWNLOADED=$((d_mt + d_t + d_c + d_g))
TOTAL_SKIPPED=$((s_mt + s_t + s_c + s_g))
TOTAL_FAILED=$((f_mt + f_t + f_c + f_g))

# Print category summaries
for category in movetools tools commands guides; do
    case "$category" in
        movetools) d=$d_mt; s=$s_mt; f=$f_mt ;;
        tools) d=$d_t; s=$s_t; f=$f_t ;;
        commands) d=$d_c; s=$s_c; f=$f_c ;;
        guides) d=$d_g; s=$s_g; f=$f_g ;;
    esac
    
    if [ $d -gt 0 ] || [ $s -gt 0 ] || [ $f -gt 0 ]; then
        echo -n "$category: "
        
        if [ $d -gt 0 ]; then
            echo -n -e "${GREEN}${d} downloaded${NC}"
        fi
        
        if [ $s -gt 0 ]; then
            [ $d -gt 0 ] && echo -n ", "
            echo -n -e "${YELLOW}${s} skipped${NC}"
        fi
        
        if [ $f -gt 0 ]; then
            [ $d -gt 0 ] || [ $s -gt 0 ] && echo -n ", "
            echo -n -e "${RED}${f} failed${NC}"
        fi
        
        echo ""
    fi
done

echo ""
echo "Total:"
print_success "$TOTAL_DOWNLOADED files downloaded successfully"

if [ $TOTAL_SKIPPED -gt 0 ]; then
    print_info "$TOTAL_SKIPPED files skipped (already exist)"
fi

if [ $TOTAL_FAILED -gt 0 ]; then
    print_error "$TOTAL_FAILED files failed to download"
fi

# Clean up
rm -f "$STATS_FILE"

echo ""
if [ $TOTAL_DOWNLOADED -gt 0 ] || [ $TOTAL_SKIPPED -gt 0 ]; then
    print_success "Resources available in current directory"
else
    print_error "No files were downloaded"
    exit 1
fi
